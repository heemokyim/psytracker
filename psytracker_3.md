
# 4. NumPy 기본 : 배열과 벡터계산
  - Numpy는 과학계산컴퓨팅과 데이터분석에 필요한 기본페키지
  - 다차원배열인 ndarray
  - 반복문 작성없이 전체 데이텅 배열에 대해 빠른 연산제공
  - 배열이나 데이터를 디스크에 쓰거나 읽을 수 있는 도구와 메모리에 올려진 파일을 사용하는 도구
  - 선형대수, 난수발생기, 푸리에 변환기능

### 데이터 분석에서 중요하게 사용되는 기능
  - 백터배열상에 데이터 개조, 정제, 부분집합, 필터링, 변형 등 연산의 빠른 수행
  - 정렬, 유일원소 찾기, 집합연산 같은 일반적인 배열처리 알고리즘
  - 통계의 효과적인 표현과 데이터의 수집/요약
  - 다른 종류의 데이터 묶음을 병합하고 엮기위한 데이터 정렬과 데이터간의 관계조작
  - if-else-elif를 포함하는 반복문 대신 사용할수 있는 조건절을 표현할 수 있는 배열 표현
  - 데이터 그룹 전체에 적용할 수 있는 수집,변형,함수적용 등 데이터처리

## 4.1 ndarray : 다차원 배열객체
  - N차원의 객체 또는 ndarray로 파이썬에서 대규모 데이터 집합을 담을수 있는 구조
  - 수학적인 연산을 수행할 수 있도록 해줌
  - naarray는 같은 종류의 데이터를 담을 수 있는 포괄적인 다차원배열
  - 모든 배열은 각차원의 크리를 알려주는 shape라는 튜플과
  - 배열에 저장된 자료형을 알려주는 dtype이라는 개체를 갖고 있다.

## 4.1.1 ndarray 생성
  - 배열을 생성하는 방법은 array함수를 사용하는 것
  - 파이썬의 리스트를 변환하여 생성할수도 있음


```python
import numpy as np
```


```python
data1 = [6, 7.5, 8, 0, 1]
```


```python
arr1 = np.array(data1)
```


```python
arr1
```




    array([ 6. ,  7.5,  8. ,  0. ,  1. ])




```python
data2 = [[1, 2, 3, 4],[5, 6, 7, 8]]
```


```python
arr2 = np.array(data2)
```


```python
arr2
```




    array([[1, 2, 3, 4],
           [5, 6, 7, 8]])




```python
arr2.ndim
```




    2




```python
arr2.shape
```




    (2L, 4L)




```python
arr1.dtype
```




    dtype('float64')




```python
arr2.dtype
```




    dtype('int32')



  - np.array는 새로운 배열을 생성하는 함수를 갖고 있음
  - zeros, ones는 주어진 길이나 모양에 각각 0과1이 들어있는 배열을 생성함
  - empty함수는 초기화 되지않은 배열을 생성함
  - 이런 메서드를 활용해 다차원배열을 생성하려면 원하는 형태의 튜플을 넘기면됨


```python
np.zeros(10)
```




    array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])




```python
np.zeros((3,6))
```




    array([[ 0.,  0.,  0.,  0.,  0.,  0.],
           [ 0.,  0.,  0.,  0.,  0.,  0.],
           [ 0.,  0.,  0.,  0.,  0.,  0.]])




```python
np.empty((2, 3, 2))
```




    array([[[  3.27288214e-316,   0.00000000e+000],
            [  0.00000000e+000,   0.00000000e+000],
            [  0.00000000e+000,   0.00000000e+000]],
    
           [[  0.00000000e+000,   0.00000000e+000],
            [  0.00000000e+000,   0.00000000e+000],
            [  0.00000000e+000,   0.00000000e+000]]])



  - arange는 파이썬의 range함수의 배열버전
  - 자료형이 명시되지 않을 경우 float64(부동소수점)
  - eye, identity는 N*N 단위 행렬생성(0,1대각행렬)


```python
np.arange(15)
```




    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])



## 4.1.2 ndarray의 자료형
  - 자료형 dtype은 ndarray가 특정 데이터를 메모리에서 해성하기 위해 필요한 정보를 담고 있는 특수한객체


```python
arr1 = np.array([1,2,3], dtype=np.float64)
```


```python
arr1.dtype
```




    dtype('float64')




```python
arr2 = np.array([1,2,3], dtype=np.int32)
```


```python
arr2.dtype
```




    dtype('int32')



  - ndarrydml astype메서드를 사용해 배열의 dtype을 다른 형으로 명시적 변경이 가능
  - 부동소수점숫자를 정수형으로 바꾸면 소수점 아래는 버려짐


```python
arr = np.array([1,2,3,4,5])
```


```python
arr.dtype
```




    dtype('int32')




```python
float_arr = arr.astype(np.float64)
```


```python
float_arr.dtype
```




    dtype('float64')




```python
arr = np.array([3.2, 3.3])
```


```python
arr
```




    array([ 3.2,  3.3])




```python
arr.astype(np.int32)
```




    array([3, 3])



  - 문자열을 담고있는 배열이 있다면 astype로 숫자로 변환가능


```python
numeric_strings = np.array(["1.4", "2", "4"], dtype=np.string_)
```


```python
numeric_strings.astype(float)
```




    array([ 1.4,  2. ,  4. ])



## 4.1.3 배열과 스칼라연산
  - 배열 for문을 반복하지 않고 데이터를 일괄처리할수 있기에 중요함
  - 이를 벡터화라고 하며 크기가 같은 배열간 산술연산은 배열의 각 요소 단위로 적용됨


```python
arr = np.array([[1,2,3],[4,5,6]], dtype=np.float64)
arr
```




    array([[ 1.,  2.,  3.],
           [ 4.,  5.,  6.]])




```python
arr*arr
```




    array([[  1.,   4.,   9.],
           [ 16.,  25.,  36.]])




```python
arr-arr
```




    array([[ 0.,  0.,  0.],
           [ 0.,  0.,  0.]])




```python
1/arr
```




    array([[ 1.        ,  0.5       ,  0.33333333],
           [ 0.25      ,  0.2       ,  0.16666667]])



## 4.1.4 색인 및 슬라이싱 기초
  - 파이썬 리스트와 유사하게 작동함


```python
arr = np.arange(10)
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
arr[5]
```




    5




```python
arr[5:8]
```




    array([5, 6, 7])




```python
arr[5:8] = 12
arr
```




    array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])



  - 배열의 일부를 slice하여 수정하면 수정내용이 원배열에 전파됨
  - 데이터 복사를 하지 않는 이유는 성능과 메모리문제때문
  - 슬라이스의 복사본을 얻고 싶으면 arr[5:8].copy()라고 명시


```python
arr_slice = arr[5:8]
arr_slice[1] =12345
arr
```




    array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,     9])




```python
arr_slice[:] = 64
arr
```




    array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])



  - 다차원의 배열에서는 각색인은 요소는 스칼라값이 아닌 1차원배열이 됨
  - 개별요소는 콤마로 구분된 색인 리스트를 넘기면 됨


```python
arr2d = np.array([[1,2,3], [4,5,6], [7,8,9]])
arr2d[2]
```




    array([7, 8, 9])




```python
arr2d[0][2]
```




    3




```python
arr2d[0,2]
```




    3



  - 2X2X3배열이라면 arr[0]은 2*3배열이다.


```python
arr3d = np.array([[[1,2,3],[4,5,6]], [[7,8,9],[10,11,12]]])
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0]
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
old_value = arr3d[0].copy()
arr3d[0] = 42
arr3d
```




    array([[[42, 42, 42],
            [42, 42, 42]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[0] = old_value
arr3d
```




    array([[[ 1,  2,  3],
            [ 4,  5,  6]],
    
           [[ 7,  8,  9],
            [10, 11, 12]]])




```python
arr3d[1,0]
```




    array([7, 8, 9])




```python
arr3d[1,0,0]
```




    7



  - 슬라이스 색인


```python
arr[1:6]
```




    array([ 1,  2,  3,  4, 64])




```python
arr2d
```




    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])




```python
arr2d[:2]
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
arr2d[:2, 1:]
```




    array([[2, 3],
           [5, 6]])




```python
arr2d[1, :2]
```




    array([4, 5])




```python
arr2d[2, :1]
```




    array([7])




```python
arr2d[:, :1]
```




    array([[1],
           [4],
           [7]])




```python
arr2d[:2, 1:] = 0
arr2d
```




    array([[1, 0, 0],
           [4, 0, 0],
           [7, 8, 9]])



## 4.1.5 불리언 색인
  - 중복이름이 포함된 배열
  - numpy.random모듈에 있는 randn함수를 사용해 임의 정규본포데이터 생성


```python
names = np.array(['bob', "joe", "will", "bob", "will", "joe", "joe"])
data = np.random.randn(7, 4)
names
```




    array(['bob', 'joe', 'will', 'bob', 'will', 'joe', 'joe'], 
          dtype='|S4')




```python
data
```




    array([[ -3.92317318e-01,  -6.03914270e-01,   8.48591235e-01,
             -8.00156834e-02],
           [  1.11190664e+00,   8.50839244e-01,   8.69748190e-01,
              1.11428577e+00],
           [ -3.36684594e-01,  -1.32313888e+00,  -7.83013277e-01,
             -9.34403169e-01],
           [  1.53282453e+00,   1.81278989e+00,   2.30317901e+00,
              2.53929729e-01],
           [ -6.30085620e-01,  -5.54677111e-01,   2.33852303e-01,
             -1.16647879e+00],
           [ -5.39246807e-01,  -6.30913936e-02,   7.67750812e-02,
             -1.90506689e-01],
           [  8.48573809e-01,   2.07685620e+00,  -9.28173868e-01,
             -6.77369843e-04]])




```python
names == 'bob'
```




    array([ True, False, False,  True, False, False, False], dtype=bool)




```python
data[names == 'bob']
```




    array([[-0.39231732, -0.60391427,  0.84859123, -0.08001568],
           [ 1.53282453,  1.81278989,  2.30317901,  0.25392973]])



  - 불리안 배열은 반드시 색인하려는 축의 길이와 동일한 길이를 가져야함
  - 불리언 배열 색인도 슬라이스 또는 숙자 색인과 혼용 가능
  - 불리언 색인으로 데이터를 선태하면 항상 데이터 복사가 이뤄짐


```python
data[names == "bob", 2:]
```




    array([[ 0.84859123, -0.08001568],
           [ 2.30317901,  0.25392973]])




```python
data[names == "bob", 3]
```




    array([-0.08001568,  0.25392973])




```python
names != 'bob'
```




    array([False,  True,  True, False,  True,  True,  True], dtype=bool)




```python
data[-(names == 'bob')]
```

    C:\Anaconda2\lib\site-packages\ipykernel\__main__.py:1: DeprecationWarning: numpy boolean negative, the `-` operator, is deprecated, use the `~` operator or the logical_not function instead.
      if __name__ == '__main__':
    




    array([[  1.11190664e+00,   8.50839244e-01,   8.69748190e-01,
              1.11428577e+00],
           [ -3.36684594e-01,  -1.32313888e+00,  -7.83013277e-01,
             -9.34403169e-01],
           [ -6.30085620e-01,  -5.54677111e-01,   2.33852303e-01,
             -1.16647879e+00],
           [ -5.39246807e-01,  -6.30913936e-02,   7.67750812e-02,
             -1.90506689e-01],
           [  8.48573809e-01,   2.07685620e+00,  -9.28173868e-01,
             -6.77369843e-04]])




```python
mask = (names == "bob") | (names == "will")
mask
```




    array([ True, False,  True,  True,  True, False, False], dtype=bool)




```python
data[mask]
```




    array([[-0.39231732, -0.60391427,  0.84859123, -0.08001568],
           [-0.33668459, -1.32313888, -0.78301328, -0.93440317],
           [ 1.53282453,  1.81278989,  2.30317901,  0.25392973],
           [-0.63008562, -0.55467711,  0.2338523 , -1.16647879]])




```python
data[data<0] = 0
data
```




    array([[ 0.        ,  0.        ,  0.84859123,  0.        ],
           [ 1.11190664,  0.85083924,  0.86974819,  1.11428577],
           [ 0.        ,  0.        ,  0.        ,  0.        ],
           [ 1.53282453,  1.81278989,  2.30317901,  0.25392973],
           [ 0.        ,  0.        ,  0.2338523 ,  0.        ],
           [ 0.        ,  0.        ,  0.07677508,  0.        ],
           [ 0.84857381,  2.0768562 ,  0.        ,  0.        ]])




```python
data[names != 'joe'] = 7
data
```




    array([[ 7.        ,  7.        ,  7.        ,  7.        ],
           [ 1.11190664,  0.85083924,  0.86974819,  1.11428577],
           [ 7.        ,  7.        ,  7.        ,  7.        ],
           [ 7.        ,  7.        ,  7.        ,  7.        ],
           [ 7.        ,  7.        ,  7.        ,  7.        ],
           [ 0.        ,  0.        ,  0.07677508,  0.        ],
           [ 0.84857381,  2.0768562 ,  0.        ,  0.        ]])



## 4.1.6 팬시색인
  - 팬시 색인은 정수배열을 사용한 색인을 설명하기위해 넘파이에서 차용한 단어
  - 8X4 크기의 배열이 있다고 하자.


```python
arr = np.empty((8, 4))

for i in range(8):
    arr[i] = i
    
arr
```




    array([[ 0.,  0.,  0.,  0.],
           [ 1.,  1.,  1.,  1.],
           [ 2.,  2.,  2.,  2.],
           [ 3.,  3.,  3.,  3.],
           [ 4.,  4.,  4.,  4.],
           [ 5.,  5.,  5.,  5.],
           [ 6.,  6.,  6.,  6.],
           [ 7.,  7.,  7.,  7.]])




```python
  - 특정 행을 선택
```


```python
arr[[4, 3, 0, 6]]
```




    array([[ 4.,  4.,  4.,  4.],
           [ 3.,  3.,  3.,  3.],
           [ 0.,  0.,  0.,  0.],
           [ 6.,  6.,  6.,  6.]])




```python
arr[[-3, -5, -7]]
```




    array([[ 5.,  5.,  5.,  5.],
           [ 3.,  3.,  3.,  3.],
           [ 1.,  1.,  1.,  1.]])



  - 다차원 색인 배열을 넘기는것은 다름. 
  - 각각 색인 튜플에 대응하는 1차원 배열이 선택된다.


```python
arr = np.arange(32).reshape((8, 4))
arr
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15],
           [16, 17, 18, 19],
           [20, 21, 22, 23],
           [24, 25, 26, 27],
           [28, 29, 30, 31]])




```python
arr[[1,5,7,2], [0,3,1,2]]
```




    array([ 4, 23, 29, 10])




```python
arr[[1,5,7,2]][:, [0,3,1,2]]
```




    array([[ 4,  7,  5,  6],
           [20, 23, 21, 22],
           [28, 31, 29, 30],
           [ 8, 11,  9, 10]])



## 4.1.7 배열 전치와 축 바꾸기
  - 배열전치는 데이터를 복사하지 않고 모양을 바꿀수있다.
  - ndarry는 transpose메서드와 T라는 이름의 특수한 속성을 갖고 있다.


```python
arr = np.arange(15).reshape((3,5))
arr
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
arr.T
```




    array([[ 0,  5, 10],
           [ 1,  6, 11],
           [ 2,  7, 12],
           [ 3,  8, 13],
           [ 4,  9, 14]])




```python
arr = np.random.randn(6,3)
arr
```




    array([[ 0.62366409, -0.24194553, -0.77776489],
           [ 0.43981743, -0.09060237, -1.19742708],
           [-0.78367816,  0.33322279,  0.46640793],
           [ 0.26553524, -0.3476754 , -0.40093292],
           [-0.48549409, -0.95800038, -0.95980045],
           [-0.87271443, -0.78506208,  1.10020475]])



  - 행렬의 내적을 np.dot을 이용해서 구할수있다.


```python
np.dot(arr.T, arr)
```




    array([[ 2.26439169,  0.60603779, -1.97787598],
           [ 0.60603779,  1.83274923,  0.6472389 ],
           [-1.97787598,  0.6472389 ,  4.5487008 ]])



  - 다차원 배열의 경우 transpose메서드는 튜플로 축번호를 받아서 치환한다.


```python
arr = np.arange(16).reshape((2, 2, 4))
arr
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7]],
    
           [[ 8,  9, 10, 11],
            [12, 13, 14, 15]]])




```python
arr.transpose((1, 0, 2))
```




    array([[[ 0,  1,  2,  3],
            [ 8,  9, 10, 11]],
    
           [[ 4,  5,  6,  7],
            [12, 13, 14, 15]]])



  - swapaxes메서드는 2개의 축번호를 받아서 배열을 뒤바꾼다.


```python
arr
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7]],
    
           [[ 8,  9, 10, 11],
            [12, 13, 14, 15]]])




```python
arr.swapaxes(1,2)
```




    array([[[ 0,  4],
            [ 1,  5],
            [ 2,  6],
            [ 3,  7]],
    
           [[ 8, 12],
            [ 9, 13],
            [10, 14],
            [11, 15]]])



## 4.2 유니버설 함수
  - ufunc라고 불리는 유니버설 함수는 ndarray안에 있는 데이터 원소별로 연산을 수행하는 함수
  - 간단한 한수를 고속으로 수행할수 있는 벡터화된 래퍼함수
  - ufunc는 sqrt나 exp같은 간단한 변형을 전체 원소에 적용할 수 있다.


```python
arr = np.arange(10)
np.sqrt(arr)
```




    array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
            2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])




```python
np.exp(arr)
```




    array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,
             2.00855369e+01,   5.45981500e+01,   1.48413159e+02,
             4.03428793e+02,   1.09663316e+03,   2.98095799e+03,
             8.10308393e+03])



  - 2개의 인자를 취해서 단일 배열을 반환하는 함수를 이항 유니버서 함수라 함


```python
x = np.random.randn(8)
y = np.random.randn(8)
```


```python
x
```




    array([-1.19782332, -0.48078808,  0.31090484,  0.70448932,  0.9570743 ,
            0.0699674 ,  0.76345436, -0.21957386])




```python
y
```




    array([ 1.16071634, -1.05211345, -1.12524317,  0.61143642,  0.45002719,
            2.87767203, -1.68255514,  1.10015054])




```python
np.maximum(x,y)
```




    array([ 1.16071634, -0.48078808,  0.31090484,  0.70448932,  0.9570743 ,
            2.87767203,  0.76345436,  1.10015054])




```python
  - 여려개 배열을 반환하는 함수도 있다. 
  - modf는 분수를 받아 몫과 나머지를 함께 반환한다.
```


```python
arr = np.random.randn(7)*5
np.modf(arr)
```




    (array([-0.24345421,  0.40159944,  0.34594801, -0.43913061, -0.17793298,
             0.94090987,  0.95401323]), array([-2.,  5.,  3., -5., -3.,  0.,  3.]))



  - 140p 유니버설 함수 목록 각자 학습합시다!!!

## 4.3 배열을 사용한 데이터 처리
  - 배열 연산을 사용해 반복문을 제거하는 기법을 백터화라고 함
  - 벡터화 배열에 대한 연산은 순수 파이썬 연산에 비해 2-3배에서 수십배까지 빠름
  - 12장에서 브로드캐스팅을 배움, 이는 강력한 벡터연산방법
  - sqrt(x^2 + y^2) 계산한다고 하자, np.meshgrid함수는 2개 1차원배열을 받아 가능한 모든 (x,y)짝을 만들수 있는 2차원 배열을 2개 반환한다.


```python
points = np.arange(-5, 5, 0.01) #천개 포인트 생성
xs, ys = np.meshgrid(points, points)
ys
```




    array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
           [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
           [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
           ..., 
           [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
           [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
           [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])




```python
import matplotlib.pyplot as plt
```


```python
z = np.sqrt(xs**2 + ys**2)
z
```




    array([[ 7.07106781,  7.06400028,  7.05693985, ...,  7.04988652,
             7.05693985,  7.06400028],
           [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
             7.04985815,  7.05692568],
           [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
             7.04278354,  7.04985815],
           ..., 
           [ 7.04988652,  7.04279774,  7.03571603, ...,  7.0286414 ,
             7.03571603,  7.04279774],
           [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
             7.04278354,  7.04985815],
           [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
             7.04985815,  7.05692568]])




```python
plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()
```




    <matplotlib.colorbar.Colorbar instance at 0x000000000B7298C8>




```python
plt.title("image plot of $\sqrt{x^2+y^2}$ for a grid of values")
```




    <matplotlib.text.Text at 0xb6309e8>



## 4.3.1 배열 연산으로 조건저 표현하기
  - numpy.where함수는 <x if조건 else y> 같은 삼항식의 벡터화된 버전
  - 다음과 같은 3개 배열이 있다고 하자


```python
xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
cond = np.array([True, False, True, True, False])
```

  - cond의 값이 True 일때 xarr값이나 yarr값을 취하고 싶다면 다음과 같이 작성할수 있다.


```python
result = [(x if c else y)
         for x,y,c in zip(xarr, yarr, cond)]
result
```




    [1.1000000000000001, 2.2000000000000002, 1.3, 1.3999999999999999, 2.5]



  - 위 방법은 느리며 다차원배열에서 사용못함 np.where를 사용하면 됨


```python
result = np.where(cond, xarr, yarr)
result
```




    array([ 1.1,  2.2,  1.3,  1.4,  2.5])



  - 일반적으로 where는 다른배열에 기반해 새로운 배열을 만드는데 사용
  - 임의 생성된 데이터가 있는 행렬에서 양수는 2, 음수는 -2로 바꿔보자


```python
arr = np.random.randn(4,4)
arr
```




    array([[-1.10010097,  0.41234989,  1.37201893, -1.20564353],
           [-0.54114431, -1.08463482, -0.42049728, -1.24189205],
           [ 1.04955108, -0.10107721,  1.45368747,  1.104876  ],
           [-0.32281547, -0.43067613,  1.16810328,  0.79834716]])




```python
np.where(arr>0, 2, -2) #양수는 2 음수는 -2
```




    array([[-2,  2,  2, -2],
           [-2, -2, -2, -2],
           [ 2, -2,  2,  2],
           [-2, -2,  2,  2]])




```python
np.where(arr>0, 2, arr) #양수만 2로 바꿈
```




    array([[-1.10010097,  2.        ,  2.        , -1.20564353],
           [-0.54114431, -1.08463482, -0.42049728, -1.24189205],
           [ 2.        , -0.10107721,  2.        ,  2.        ],
           [-0.32281547, -0.43067613,  2.        ,  2.        ]])



##4.3.2 수학메서드와 통계메서드
  - 최상위 함수를 사용하거나 배열의 인스턴스 메서드를 사용할수 있다.


```python
arr = np.random.randn(5,4) #정규난수
arr
```




    array([[-0.22757558, -0.59404459,  0.42025839, -0.55738626],
           [-2.39252613,  0.22179769, -1.37333585,  0.67303031],
           [-0.00267429,  2.22341655, -1.1460412 ,  0.79591267],
           [-1.81486032,  0.13527957,  0.11130391, -1.9872796 ],
           [-0.00964929, -1.7263261 ,  1.11287505,  1.07413716]])




```python
arr.mean()
```




    -0.25318439494300382




```python
np.mean(arr)
```




    -0.25318439494300382




```python
arr.sum()
```




    -5.0636878988600769




```python
arr.mean(axis=1) #1열
```




    array([-0.23968701, -0.7177585 ,  0.46765343, -0.88888911,  0.11275921])




```python
arr.sum(0) #배열의 첫번째 인자
```




    array([ -4.44728561e+00,   2.60123123e-01,  -8.74939689e-01,
            -1.58572173e-03])



  - cumsum(누적합), cumprod(누적곱)는 중간 계산값을 담고 있는 배열을 반환


```python
arr = np.array([[0,1,2], [3,4,5], [6,7,8]])
arr.cumsum(0)
```




    array([[ 0,  1,  2],
           [ 3,  5,  7],
           [ 9, 12, 15]])




```python
arr.cumprod(1)
```




    array([[  0,   0,   0],
           [  3,  12,  60],
           [  6,  42, 336]])



  - 146p 통계메서드 각자 공부합시다!!

## 4.3.3 불리언 배열을 위한 메서드 
  - 불리언은 1=true , 2=false로 취급됨
  - sum메서드를 실행하면 True 개수를 반환
  - any은 하나이상 True인지, all은 모두 True인지 검사


```python
arr = np.random.randn(100)
```


```python
(arr>0).sum()
```




    52




```python
bools = np.array([False, False, True, False])
bools.any()
```




    True




```python
bools.all()
```




    False



## 4.3.4 정렬
  - 리스트와 마찬가지로 sort함수로 정렬
  - np.sort는 배열을 직접정렬하지 않고 정렬된 복사본을 반환


```python
arr = np.random.randn(8)
arr
```




    array([-0.36769682,  1.19143399,  0.05684431,  1.84843248, -1.28537847,
            0.23713292, -0.27885952, -1.86740478])




```python
arr.sort()
arr
```




    array([-1.86740478, -1.28537847, -0.36769682, -0.27885952,  0.05684431,
            0.23713292,  1.19143399,  1.84843248])




```python
arr = np.random.randn(5,3)
arr
```




    array([[ 0.5867955 ,  1.93575052, -0.12840951],
           [ 0.76818525,  0.82846495, -0.87268065],
           [-0.93295612, -0.30500399,  0.23291271],
           [-0.15337132, -0.58633904,  1.25711181],
           [-0.79171304, -0.51080999, -0.25381943]])




```python
arr.sort(1)
arr
```




    array([[-0.12840951,  0.5867955 ,  1.93575052],
           [-0.87268065,  0.76818525,  0.82846495],
           [-0.93295612, -0.30500399,  0.23291271],
           [-0.58633904, -0.15337132,  1.25711181],
           [-0.79171304, -0.51080999, -0.25381943]])




```python
arr = np.random.randn(1000)
arr.sort()
arr[int(0.05*len(arr))] #5% 값
```




    -1.6820729627256354



## 4.3.5 집합함수
  - unique(x) : 중복되는 원소 제거후 정렬하여 반환
  - intersect1d(x,y) : 배열 x와 y에 공통적으로 존재하는 원소를 정렬하여 반환
  - union1d(x,y) : 두 배열의 합집합을 반환
  - in1d(x,y) : x원소중 y원소를 포함하는지 불리언값으로 배열을 반환
  - setdiff1d(x,y) : 차집합
  - setxor1d(x,y) : 한 배열에 포함되지만 두배열에 모두 포함되지않은 대칭차집합 반환


```python
int = np.array([3,3,1,1,2,2])
np.unique(int)
```




    array([1, 2, 3])




```python
set(int)
```




    {1, 2, 3}




```python
x = np.array([1,2,3,4,5,6])
np.in1d(x, [1,2,3])
```




    array([ True,  True,  True, False, False, False], dtype=bool)



## 4.4 배열의 파일 입출력
  - 넘파이는 텍스트나 바이너리 형식의 파일로 부터 데이터를 불러오고 저장할수 있다.  
  - 표형식은 5장 pandas에서 배우겠다.

## 4.4.1 배열을 바이너리 형식으로 디스크에 저장
  - np.save와 np.load함수사용 / .npy 파일로 저장된다


```python
arr = np.arange(10)
np.save('some_array', arr)
```


```python
np.load('some_array.npy')
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



  - np.savez함수는 여러개의 배열을 압축된 형식을 저장
  - 저장하려는 배열은 키워드 인자형태로 전달됨
  - npz파일을 불러올때는 각가의 배열을 언제든 불러올수 있게 사전형식의 객체에 저장


```python
np.savez('array_archive.npz', a=arr, b=arr)
```


```python
arch = np.load('array_archive.npz')
```


```python
arch['b']
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



## 4.4.2 텍스트파일 불러오기와 저장하기
  - 판다스에서 제공하는 read_csv와 read_table 함수위주로 설명
  - np.loadtxt나 np.getfromtxt도 유용할수 있음

  - 쉼표로 구분된 csv파일 a.txt
  - np.loadtxt("'a.txt", deliter',')

## 4.5 선형대수
  - 행렬곱셉은 배열 메서드이자 numpy 네임스페이스안에 있는 함수인 dot함수 사용


```python
x = np.array([[1., 2., 3.],[4., 5., 6.]])
y = np.array([[6., 23.],[-1, 7],[8, 9]])
```


```python
x
```




    array([[ 1.,  2.,  3.],
           [ 4.,  5.,  6.]])




```python
y
```




    array([[  6.,  23.],
           [ -1.,   7.],
           [  8.,   9.]])




```python
x.dot(y)  #np.dot(x,y) 동일
```




    array([[  28.,   64.],
           [  67.,  181.]])



  - numpy.linalg 는 행렬의 역핼렬, 행렬식을 포함하고 있다.


```python
from numpy.linalg import inv, qr
```


```python
x = np.random.randn(5,5)
mat = x.T.dot(x)
inv(mat)
```




    array([[ 0.33897462, -0.16056859, -0.01993217,  0.13299102,  0.14631496],
           [-0.16056859,  0.23546092,  0.11312724, -0.39291307, -0.01729801],
           [-0.01993217,  0.11312724,  0.29446243, -0.35127608, -0.02472399],
           [ 0.13299102, -0.39291307, -0.35127608,  1.87529246, -0.08842589],
           [ 0.14631496, -0.01729801, -0.02472399, -0.08842589,  0.24276222]])




```python
mat.dot(inv(mat))
```




    array([[  1.00000000e+00,  -1.44227978e-16,   5.56990942e-17,
             -3.11480646e-16,   4.46025691e-17],
           [  2.47607833e-16,   1.00000000e+00,   4.76438292e-17,
             -2.84410179e-16,   5.38028375e-17],
           [ -7.04814276e-17,   1.73482623e-16,   1.00000000e+00,
             -4.46048534e-16,   6.67001215e-18],
           [  3.54863202e-17,  -6.39699093e-17,  -3.65681085e-17,
              1.00000000e+00,  -3.86198083e-18],
           [  2.31107463e-16,   4.05845437e-18,  -1.16903405e-16,
             -1.71233857e-17,   1.00000000e+00]])




```python
q, r = qr(mat)
r
```




    array([[-10.50761549, -12.24210454,   4.45769979,  -0.64811495,
              7.31000024],
           [  0.        ,  -6.17491746,   0.70628394,  -1.38577868,
             -2.46009121],
           [  0.        ,   0.        ,  -4.5219449 ,  -0.99730468,
             -1.05060297],
           [  0.        ,   0.        ,   0.        ,  -0.53004236,
             -0.90660442],
           [  0.        ,   0.        ,   0.        ,   0.        ,
              3.35066772]])



  - 154p 선형대수 함수 각자 공부합시다!!!

## 4.6 난수 생성 
  - numpy.random모듈은 다양한 종률의 확률분포로부터 표본을 생성하는데 사용
  - normal, binomial, beta, chisquare, gamma, uniform


```python
sample = np.random.normal(size=(4,4)) #4*4크기의 정규분포 표본생성
sample
```




    array([[-0.45473568, -0.38356223,  0.5322944 ,  0.39958252],
           [-0.02725949, -1.20982289,  0.1310043 , -0.75521441],
           [-1.02131744, -1.23881185,  0.57745226, -0.68357716],
           [-1.58808319, -0.06738073, -0.2897216 , -0.38578869]])



## 4.7 계단오르기 예제


```python

```
